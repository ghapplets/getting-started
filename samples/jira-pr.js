/*
* Creates a pull request on GitHub when a Jira issue is opened.
*
* Setup a Jira Webhook to your ngrok/fission installation:
* E.g. 
*   URL http://9560d9c6.ngrok.io/gh/applets/jira-pr
*   Events
*   Issue related events
*   JQL: PROJECT="Your Project Name"
*   Issue: created, updated
* 
* Configure the constants below based on your needs.
*/

const octokit = require("@octokit/rest")();
const jsonwebtoken = require("jsonwebtoken");
const fs = require("fs");

// Constants
const JIRA_ISSUE_LABEL = "develop"; // Matches a specific Jira label
const REPO_NAME = "test-test"; // The name of your repository
const REPO_OWNER = "pierluigi"; // The repository owner (user or org)
const BASE_BRANCH = "master"; // target branch for PRs

// Secrets
const appId = parseInt(
  Buffer.from(
    fs.readFileSync("/secrets/default/gh-applets/GH_APP_ID"),
    "base64"
  ).toString("ascii")
);

// TODO automate getting installation ID on first webhook
// Use first GitHub webhook call to store ID to a ConfigMap?
const installation_id = parseInt(
  Buffer.from(
    fs.readFileSync("/secrets/default/gh-applets/GH_INST_ID"),
    "base64"
  ).toString("ascii")
);

const pem = Buffer.from(
  fs.readFileSync("/secrets/default/gh-applets/GH_PEM_KEY"),
  "base64"
).toString("ascii");

function generateJwtToken() {
  // Sign with RSA SHA256
  return jsonwebtoken.sign(
    {
      iat: Math.floor(new Date() / 1000),
      exp: Math.floor(new Date() / 1000) + 60,
      iss: appId
    },
    pem,
    { algorithm: "RS256" }
  );
}

async function createBranchFromIssue({
  key,
  fields: { description, summary }
}) {
  const ref = `refs/heads/${key}`;
  const owner = REPO_OWNER;
  const repo = REPO_NAME;

  try {
    await octokit.authenticate({
      type: "app",
      token: generateJwtToken()
    });

    const {
      data: { token }
    } = await octokit.apps.createInstallationToken({
      installation_id
    });

    octokit.authenticate({ type: "token", token });
  } catch (e) {
    console.error("Authentication error", e);
  }

  try {
    // 0. Get latest commit sha from base branch
    const getCommitsResult = await octokit.repos.getCommits({
      owner,
      repo,
      sha: BASE_BRANCH,
      per_page: 1
    });

    // 1. create new reference for new branch
    const createReferenceResult = await octokit.gitdata.createReference({
      owner,
      repo,
      ref,
      sha: getCommitsResult.data[0].sha
    });

    // 2. get commit from reference sha
    const getCommitResult = await octokit.gitdata.getCommit({
      owner,
      repo,
      commit_sha: createReferenceResult.data.object.sha
    });

    // 3. create commit
    const createCommitResult = await octokit.gitdata.createCommit({
      owner,
      repo,
      message: "Autogenerated commit " + new Date().toUTCString(),
      tree: getCommitResult.data.tree.sha,
      parents: [createReferenceResult.data.object.sha]
    });

    // 4. update reference
    const createRpdate_referenceResult = await octokit.gitdata.updateReference({
      owner,
      repo,
      ref: `heads/${key}`,
      sha: createCommitResult.data.sha,
      force: true
    });

    const result = await octokit.pullRequests.create({
      owner,
      repo,
      title: `${key} - ${summary}`,
      head: `${key}`,
      base: BASE_BRANCH,
      body: description
    });

    console.log(result);
    return result;
  } catch (e) {
    console.error(e);
  }
}

module.exports = async function(context) {
  const stringBody = JSON.stringify(context.request.body);
  const body = JSON.parse(stringBody);
  const { issue_event_type_name: action, issue } = body;

  try {
    let response = "";
    if (
      action === "issue_created" &&
      issue.fields.labels &&
      issue.fields.labels.includes(JIRA_ISSUE_LABEL)
    ) {
      response = await createBranchFromIssue(issue);
    }
    return {
      status: 200,
      body: {
        text: response
      },
      headers: {
        "Content-Type": "application/json"
      }
    };
  } catch (e) {
    return {
      status: 500,
      body: e
    };
  }
};
